<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Payton Gunter - Lunar Station Game</title>
    <link rel="stylesheet" href="styles.css?v=3">
    <link href="https://fonts.googleapis.com/css2?family=Roboto:wght@400;700&display=swap" rel="stylesheet">
</head>
<body>
    <header>
        <h1>Payton Gunter</h1>
        <p>Electronics Maker | Innovator | Space Advocate</p>
    </header>
    <nav>
        <ul>
            <li><a href="/">Home</a></li>
            <li><a href="/contact.html">Contact</a></li>
            <li><a href="/current-projects.html">Current Projects</a></li>
            <li><a href="/past-projects.html">Past Projects</a></li>
            <li><a href="/off-topic.html">Off Topic</a></li>
        </ul>
    </nav>
    <section id="test-game">
        <h2>Lunar Station Game</h2>
        <p>Manage your lunar space station in 3D!</p>
        <div id="game-container"></div>
    </section>
    <footer>
        <p>Contact: <span class="copyable" onclick="copyToClipboard('kerbalengineer098@gmail.com')">kerbalengineer098@gmail.com</span> | <a href="https://github.com/KerbalEngineering">GitHub</a></p>
    </footer>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r134/three.min.js"></script>
    <script>
        if (typeof THREE === 'undefined') {
            console.error('Three.js failed to load');
            alert('Three.js failed to load - check console');
        } else {
            console.log('Three.js loaded successfully');
        }

        const container = document.getElementById('game-container');
        if (!container) {
            console.error('Game container not found');
            alert('Game container not found');
        } else {
            console.log('Game container found');
            console.log('Container dimensions:', container.clientWidth, container.clientHeight);

            const scene = new THREE.Scene();
            const camera = new THREE.PerspectiveCamera(75, container.clientWidth / container.clientHeight, 0.1, 1000);
            const renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(container.clientWidth, container.clientHeight);
            container.appendChild(renderer.domElement);
            console.log('Renderer canvas added to container');

            // Station group
            const station = new THREE.Group();

            // Module 1 (short, bottom)
            const shortModuleGeometry = new THREE.CylinderGeometry(1.3, 1.3, 4, 32);
            const moduleMaterial = new THREE.MeshBasicMaterial({ color: 0x666666, wireframe: true });
            const module1 = new THREE.Mesh(shortModuleGeometry, moduleMaterial);
            module1.position.y = -2; // Center at y = -2
            station.add(module1);

            // Module 2 (habitat, top, 40% longer)
            const habitatModuleGeometry = new THREE.CylinderGeometry(1.3, 1.3, 5.6, 32); // 4 * 1.4 = 5.6
            const module2 = new THREE.Mesh(habitatModuleGeometry, moduleMaterial);
            module2.position.y = 2.8; // Center at y = 2.8 (half of 5.6)
            station.add(module2);

            // Conical ends (0.3 tall, 1.3 to 0.45 radius)
            const coneGeometry = new THREE.CylinderGeometry(0.45, 1.3, 0.3, 32);
            const coneMaterial = new THREE.MeshBasicMaterial({ color: 0x888888, wireframe: true });
            // Bottom end
            const coneBottom = new THREE.Mesh(coneGeometry, coneMaterial);
            coneBottom.position.y = -4.15; // -2 - 2 - 0.15
            station.add(coneBottom);
            // Top end
            const coneTop = new THREE.Mesh(coneGeometry, coneMaterial);
            coneTop.position.y = 5.95; // 2.8 + 2.8 + 0.15
            coneTop.rotation.x = Math.PI; // Flip
            station.add(coneTop);
            // Middle (between modules)
            const coneMiddleBottom = new THREE.Mesh(coneGeometry, coneMaterial);
            coneMiddleBottom.position.y = 0.15; // Between modules (adjusted for new length)
            station.add(coneMiddleBottom);
            const coneMiddleTop = new THREE.Mesh(coneGeometry, coneMaterial);
            coneMiddleTop.position.y = 0.45; // Adjusted for gap
            coneMiddleTop.rotation.x = Math.PI; // Flip
            station.add(coneMiddleTop);

            // Docking ports (radius 0.45, chamfer to 0.4, total height 0.05)
            const portMiddleGeometry = new THREE.CylinderGeometry(0.45, 0.45, 0.03, 32); // Middle section
            const portChamferGeometry = new THREE.CylinderGeometry(0.4, 0.45, 0.01, 32); // Chamfer ends
            const portMaterial = new THREE.MeshBasicMaterial({ color: 0xaaaaaa, wireframe: true });

            // Bottom port
            const portBottomMiddle = new THREE.Mesh(portMiddleGeometry, portMaterial);
            portBottomMiddle.position.y = -4.325; // -4.15 - 0.15 - 0.025
            station.add(portBottomMiddle);
            const portBottomChamferTop = new THREE.Mesh(portChamferGeometry, portMaterial);
            portBottomChamferTop.position.y = -4.31; // Slightly above middle
            station.add(portBottomChamferTop);
            const portBottomChamferBottom = new THREE.Mesh(portChamferGeometry, portMaterial);
            portBottomChamferBottom.position.y = -4.34; // Slightly below middle
            portBottomChamferBottom.rotation.x = Math.PI; // Flip
            station.add(portBottomChamferBottom);

            // Top port
            const portTopMiddle = new THREE.Mesh(portMiddleGeometry, portMaterial);
            portTopMiddle.position.y = 6.115; // 5.95 + 0.15 + 0.025
            station.add(portTopMiddle);
            const portTopChamferTop = new THREE.Mesh(portChamferGeometry, portMaterial);
            portTopChamferTop.position.y = 6.13; // Slightly above
            station.add(portTopChamferTop);
            const portTopChamferBottom = new THREE.Mesh(portChamferGeometry, portMaterial);
            portTopChamferBottom.position.y = 6.1; // Slightly below
            portTopChamferBottom.rotation.x = Math.PI; // Flip
            station.add(portTopChamferBottom);

            // Middle ports (between modules)
            const portMiddleBottomMiddle = new THREE.Mesh(portMiddleGeometry, portMaterial);
            portMiddleBottomMiddle.position.y = 0; // Adjusted for new spacing
            station.add(portMiddleBottomMiddle);
            const portMiddleBottomChamferTop = new THREE.Mesh(portChamferGeometry, portMaterial);
            portMiddleBottomChamferTop.position.y = 0.015;
            station.add(portMiddleBottomChamferTop);
            const portMiddleBottomChamferBottom = new THREE.Mesh(portChamferGeometry, portMaterial);
            portMiddleBottomChamferBottom.position.y = -0.015;
            portMiddleBottomChamferBottom.rotation.x = Math.PI; // Flip
            station.add(portMiddleBottomChamferBottom);

            const portMiddleTopMiddle = new THREE.Mesh(portMiddleGeometry, portMaterial);
            portMiddleTopMiddle.position.y = 0.6; // Adjusted for new spacing
            station.add(portMiddleTopMiddle);
            const portMiddleTopChamferTop = new THREE.Mesh(portChamferGeometry, portMaterial);
            portMiddleTopChamferTop.position.y = 0.615;
            station.add(portMiddleTopChamferTop);
            const portMiddleTopChamferBottom = new THREE.Mesh(portChamferGeometry, portMaterial);
            portMiddleTopChamferBottom.position.y = 0.585;
            portMiddleTopChamferBottom.rotation.x = Math.PI; // Flip
            station.add(portMiddleTopChamferBottom);

            scene.add(station);

            camera.position.z = 15;

            function animate() {
                requestAnimationFrame(animate);
                station.rotation.y += 0.005;
                renderer.render(scene, camera);
            }
            animate();

            window.addEventListener('resize', () => {
                const width = container.clientWidth;
                const height = container.clientHeight;
                renderer.setSize(width, height);
                camera.aspect = width / height;
                camera.updateProjectionMatrix();
                console.log('Resize triggered - new dimensions:', width, height);
            });
        }

        function copyToClipboard(text) {
            const tempInput = document.createElement('textarea');
            tempInput.value = text;
            document.body.appendChild(tempInput);
            tempInput.select();
            try {
                document.execCommand('copy');
                alert('Copied to clipboard: ' + text);
            } catch (err) {
                console.error('Copy failed: ', err);
                alert('Copy failedâ€”please select and copy manually.');
            }
            document.body.removeChild(tempInput);
        }
    </script>
</body>
</html>
